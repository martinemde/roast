# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `cli-ui` gem.
# Please instead update this file by running `bin/tapioca gem cli-ui`.


# source://cli-ui//lib/cli/ui.rb#8
module CLI; end

# source://cli-ui//lib/cli/ui.rb#9
module CLI::UI
  class << self
    # Convenience Method for +CLI::UI::Prompt.any_key+
    #
    # ==== Attributes
    #
    # * +prompt+ - prompt to present
    #
    # source://cli-ui//lib/cli/ui.rb#101
    sig { params(prompt: ::String).returns(T.nilable(::String)) }
    def any_key(prompt = T.unsafe(nil)); end

    # Convenience Method for +CLI::UI::Prompt.ask+
    #
    # source://cli-ui//lib/cli/ui.rb#119
    sig do
      params(
        question: ::String,
        options: T.nilable(T::Array[::String]),
        default: T.nilable(T.any(::String, T::Array[::String])),
        is_file: T::Boolean,
        allow_empty: T::Boolean,
        multiple: T::Boolean,
        filter_ui: T::Boolean,
        select_ui: T::Boolean,
        options_proc: T.nilable(T.proc.params(handler: ::CLI::UI::Prompt::OptionsHandler).void)
      ).returns(T.any(::String, T::Array[::String]))
    end
    def ask(question, options: T.unsafe(nil), default: T.unsafe(nil), is_file: T.unsafe(nil), allow_empty: T.unsafe(nil), multiple: T.unsafe(nil), filter_ui: T.unsafe(nil), select_ui: T.unsafe(nil), &options_proc); end

    # Convenience Method for +CLI::UI::Prompt.confirm+
    #
    # ==== Attributes
    #
    # * +question+ - question to confirm
    #
    # source://cli-ui//lib/cli/ui.rb#90
    sig { params(question: ::String, default: T::Boolean).returns(T::Boolean) }
    def confirm(question, default: T.unsafe(nil)); end

    # Turn colour in Formatter, Frame, and Spinner output on or off.
    #
    # ==== Attributes
    #
    # * +bool+ - true or false; enable or disable colour.
    #
    # source://cli-ui//lib/cli/ui.rb#358
    sig { params(bool: T::Boolean).void }
    def enable_color=(bool); end

    # Check whether colour is enabled in Formatter, Frame, and Spinner output.
    # By default, colour is enabled when STDOUT is a TTY; that is, when output
    # has not been directed to another program or to a file.
    #
    # source://cli-ui//lib/cli/ui.rb#347
    sig { returns(T::Boolean) }
    def enable_color?; end

    # Turn cursor control in Formatter, Frame, and Spinner output on or off.
    #
    # ==== Attributes
    #
    # * +bool+ - true or false; enable or disable cursor control.
    #
    # source://cli-ui//lib/cli/ui.rb#378
    sig { params(bool: T::Boolean).void }
    def enable_cursor=(bool); end

    # Check whether cursor control is enabled in Formatter, Frame, and Spinner output.
    # By default, cursor control is enabled when STDOUT is a TTY; that is, when output
    # has not been directed to another program or to a file.
    #
    # source://cli-ui//lib/cli/ui.rb#367
    sig { returns(T::Boolean) }
    def enable_cursor?; end

    # Convenience Method to format text using +CLI::UI::Formatter.format+
    # Check +CLI::UI::Formatter::SGR_MAP+ for available formatting options
    #
    # https://user-images.githubusercontent.com/3074765/33799827-6d0721a2-dd01-11e7-9ab5-c3d455264afe.png
    # https://user-images.githubusercontent.com/3074765/33799847-9ec03fd0-dd01-11e7-93f7-5f5cc540e61e.png
    #
    # ==== Attributes
    #
    # * +input+ - input to format
    #
    # ==== Options
    #
    # * +enable_color+ - should color be used? default to true unless output is redirected.
    #
    # source://cli-ui//lib/cli/ui.rb#175
    sig { params(input: ::String, enable_color: T::Boolean).returns(::String) }
    def fmt(input, enable_color: T.unsafe(nil)); end

    # Convenience Method for +CLI::UI::Frame.open+
    #
    # ==== Attributes
    #
    # * +args+ - arguments for +Frame.open+
    # * +block+ - block for +Frame.open+
    #
    # source://cli-ui//lib/cli/ui.rb#241
    sig do
      type_parameters(:T)
        .params(
          text: ::String,
          color: T.nilable(T.any(::CLI::UI::Color, ::String, ::Symbol)),
          failure_text: T.nilable(::String),
          success_text: T.nilable(::String),
          timing: T.any(::Numeric, T::Boolean),
          frame_style: T.any(::CLI::UI::Frame::FrameStyle, ::String, ::Symbol),
          to: T.any(::IO, ::StringIO),
          block: T.nilable(T.proc.returns(T.type_parameter(:T)))
        ).returns(T.nilable(T.type_parameter(:T)))
    end
    def frame(text, color: T.unsafe(nil), failure_text: T.unsafe(nil), success_text: T.unsafe(nil), timing: T.unsafe(nil), frame_style: T.unsafe(nil), to: T.unsafe(nil), &block); end

    # Set the default frame style.
    # Convenience method for setting the default frame style with +CLI::UI::Frame.frame_style=+
    #
    # Raises ArgumentError if +frame_style+ is not valid
    #
    # ==== Attributes
    #
    # * +symbol+ - the default frame style to use for frames
    #
    # source://cli-ui//lib/cli/ui.rb#392
    sig { params(frame_style: T.any(::CLI::UI::Frame::FrameStyle, ::String, ::Symbol)).void }
    def frame_style=(frame_style); end

    # Glyph resolution using +CLI::UI::Glyph.lookup+
    # Look at the method signature for +Glyph.lookup+ for more details
    #
    # ==== Attributes
    #
    # * +handle+ - handle of the glyph to resolve
    #
    # source://cli-ui//lib/cli/ui.rb#46
    sig { params(handle: ::String).returns(::CLI::UI::Glyph) }
    def glyph(handle); end

    # Create a terminal link
    #
    # source://cli-ui//lib/cli/ui.rb#398
    sig { params(url: ::String, text: ::String, format: T::Boolean, blue_underline: T::Boolean).returns(::String) }
    def link(url, text, format: T.unsafe(nil), blue_underline: T.unsafe(nil)); end

    # Duplicate output to a file path
    #
    # ==== Attributes
    #
    # * +path+ - path to duplicate output to
    #
    # source://cli-ui//lib/cli/ui.rb#309
    sig do
      type_parameters(:T)
        .params(
          path: ::String,
          block: T.proc.returns(T.type_parameter(:T))
        ).returns(T.type_parameter(:T))
    end
    def log_output_to(path, &block); end

    # Convenience Method for +CLI::UI::Printer.puts+
    #
    # ==== Attributes
    #
    # * +msg+ - Message to print
    # * +kwargs+ - keyword arguments for +Printer.puts+
    #
    # source://cli-ui//lib/cli/ui.rb#202
    sig do
      params(
        msg: ::String,
        frame_color: T.nilable(T.any(::CLI::UI::Color, ::String, ::Symbol)),
        to: T.any(::IO, ::StringIO),
        encoding: ::Encoding,
        format: T::Boolean,
        graceful: T::Boolean,
        wrap: T::Boolean
      ).void
    end
    def puts(msg, frame_color: T.unsafe(nil), to: T.unsafe(nil), encoding: T.unsafe(nil), format: T.unsafe(nil), graceful: T.unsafe(nil), wrap: T.unsafe(nil)); end

    # Disable all framing within a block
    #
    # ==== Attributes
    #
    # * +block+ - block in which to disable frames
    #
    # source://cli-ui//lib/cli/ui.rb#334
    sig { type_parameters(:T).params(block: T.proc.returns(T.type_parameter(:T))).returns(T.type_parameter(:T)) }
    def raw(&block); end

    # Color resolution using +CLI::UI::Color.lookup+
    # Will lookup using +Color.lookup+ unless it's already a CLI::UI::Color (or nil)
    #
    # ==== Attributes
    #
    # * +input+ - color to resolve
    #
    # source://cli-ui//lib/cli/ui.rb#58
    sig { params(input: T.any(::CLI::UI::Color, ::String, ::Symbol)).returns(::CLI::UI::Color) }
    def resolve_color(input); end

    # Frame style resolution using +CLI::UI::Frame::FrameStyle.lookup+.
    # Will lookup using +FrameStyle.lookup+ unless it's already a CLI::UI::Frame::FrameStyle(or nil)
    #
    # ==== Attributes
    #
    # * +input+ - frame style to resolve
    #
    # source://cli-ui//lib/cli/ui.rb#74
    sig do
      params(
        input: T.any(::CLI::UI::Frame::FrameStyle, ::String, ::Symbol)
      ).returns(::CLI::UI::Frame::FrameStyle)
    end
    def resolve_style(input); end

    # Convenience Method to resolve text using +CLI::UI::Formatter.format+
    # Check +CLI::UI::Formatter::SGR_MAP+ for available formatting options
    #
    # ==== Attributes
    #
    # * +input+ - input to format
    # * +truncate_to+ - number of characters to truncate the string to (or nil)
    # * +enable_color+ - should color be used? default to true unless output is redirected.
    #
    # source://cli-ui//lib/cli/ui.rb#153
    sig { params(input: ::String, truncate_to: T.nilable(::Integer), enable_color: T::Boolean).returns(::String) }
    def resolve_text(input, truncate_to: T.unsafe(nil), enable_color: T.unsafe(nil)); end

    # Convenience Method for +CLI::UI::Spinner.spin+
    #
    # ==== Attributes
    #
    # * +args+ - arguments for +Spinner.open+
    # * +block+ - block for +Spinner.open+
    #
    # source://cli-ui//lib/cli/ui.rb#278
    sig do
      params(
        title: ::String,
        auto_debrief: T::Boolean,
        to: T.any(::IO, ::StringIO),
        block: T.proc.params(task: ::CLI::UI::Spinner::SpinGroup::Task).void
      ).returns(T::Boolean)
    end
    def spinner(title, auto_debrief: T.unsafe(nil), to: T.unsafe(nil), &block); end

    # Convenience Method to override frame color using +CLI::UI::Frame.with_frame_color+
    #
    # ==== Attributes
    #
    # * +color+ - color to override to
    # * +block+ - block for +Frame.with_frame_color_override+
    #
    # source://cli-ui//lib/cli/ui.rb#294
    sig do
      type_parameters(:T)
        .params(
          color: T.any(::CLI::UI::Color, ::String, ::Symbol),
          block: T.proc.returns(T.type_parameter(:T))
        ).returns(T.type_parameter(:T))
    end
    def with_frame_color(color, &block); end

    # source://cli-ui//lib/cli/ui.rb#180
    sig { params(input: ::String).returns(::String) }
    def wrap(input); end
  end
end

# source://cli-ui//lib/cli/ui/ansi.rb#8
module CLI::UI::ANSI
  class << self
    # source://cli-ui//lib/cli/ui/ansi.rb#206
    sig { returns(::String) }
    def clear_to_end_of_line; end

    # Returns an ANSI control sequence
    #
    # ==== Attributes
    #
    # - +args+ - Argument to pass to the ANSI control sequence
    # - +cmd+ - ANSI control sequence Command
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#60
    sig { params(args: ::String, cmd: ::String).returns(::String) }
    def control(args, cmd); end

    # Move the cursor back n columns
    #
    # ==== Attributes
    #
    # * +n+ - number of columns by which to move the cursor back
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#118
    sig { params(n: ::Integer).returns(::String) }
    def cursor_back(n = T.unsafe(nil)); end

    # Move the cursor down n lines
    #
    # ==== Attributes
    #
    # * +n+ - number of lines by which to move the cursor down
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#92
    sig { params(n: ::Integer).returns(::String) }
    def cursor_down(n = T.unsafe(nil)); end

    # Move the cursor forward n columns
    #
    # ==== Attributes
    #
    # * +n+ - number of columns by which to move the cursor forward
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#105
    sig { params(n: ::Integer).returns(::String) }
    def cursor_forward(n = T.unsafe(nil)); end

    # Move the cursor to a specific column
    #
    # ==== Attributes
    #
    # * +n+ - The column to move to
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#131
    sig { params(n: ::Integer).returns(::String) }
    def cursor_horizontal_absolute(n = T.unsafe(nil)); end

    # Restore the saved cursor position
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#176
    sig { returns(::String) }
    def cursor_restore; end

    # Save the cursor position
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#169
    sig { returns(::String) }
    def cursor_save; end

    # Move the cursor up n lines
    #
    # ==== Attributes
    #
    # * +n+ - number of lines by which to move the cursor up
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#79
    sig { params(n: ::Integer).returns(::String) }
    def cursor_up(n = T.unsafe(nil)); end

    # source://cli-ui//lib/cli/ui/ansi.rb#138
    sig { returns(::String) }
    def enter_alternate_screen; end

    # source://cli-ui//lib/cli/ui/ansi.rb#143
    sig { returns(::String) }
    def exit_alternate_screen; end

    # Hide the cursor
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#162
    sig { returns(::String) }
    def hide_cursor; end

    # source://cli-ui//lib/cli/ui/ansi.rb#211
    sig { returns(::String) }
    def insert_line; end

    # source://cli-ui//lib/cli/ui/ansi.rb#216
    sig { params(n: ::Integer).returns(::String) }
    def insert_lines(n = T.unsafe(nil)); end

    # source://cli-ui//lib/cli/ui/ansi.rb#148
    sig { returns(::Regexp) }
    def match_alternate_screen; end

    # Move to the next line
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#183
    sig { returns(::String) }
    def next_line; end

    # Move to the previous line
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#190
    sig { returns(::String) }
    def previous_line; end

    # Move to the previous n lines
    #
    # ==== Attributes
    #
    # * +n+ - number of lines by which to move the cursor up
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#201
    sig { params(n: ::Integer).returns(::String) }
    def previous_lines(n = T.unsafe(nil)); end

    # ANSI escape sequences (like \x1b[31m) have zero width.
    # when calculating the padding width, we must exclude them.
    # This also implements a basic version of utf8 character width calculation like
    # we could get for real from something like utf8proc.
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#22
    sig { params(str: ::String).returns(::Integer) }
    def printing_width(str); end

    # https://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#66
    sig { params(params: ::String).returns(::String) }
    def sgr(params); end

    # Show the cursor
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#155
    sig { returns(::String) }
    def show_cursor; end

    # Strips ANSI codes from a str
    #
    # ==== Attributes
    #
    # - +str+ - The string from which to strip codes
    #
    # source://cli-ui//lib/cli/ui/ansi.rb#48
    sig { params(str: ::String).returns(::String) }
    def strip_codes(str); end
  end
end

# source://cli-ui//lib/cli/ui/ansi.rb#11
CLI::UI::ANSI::ESC = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/color.rb#8
class CLI::UI::Color
  # Creates a new color mapping
  # Signatures can be found here:
  # https://en.wikipedia.org/wiki/ANSI_escape_code#Colors
  #
  # ==== Attributes
  #
  # * +sgr+ - The color signature
  # * +name+ - The name of the color
  #
  # source://cli-ui//lib/cli/ui/color.rb#27
  sig { params(sgr: ::String, name: ::Symbol).void }
  def initialize(sgr, name); end

  # @return [String]
  #
  # source://cli-ui//lib/cli/ui/color.rb#12
  def code; end

  # source://cli-ui//lib/cli/ui/color.rb#15
  sig { returns(::Symbol) }
  def name; end

  # source://cli-ui//lib/cli/ui/color.rb#12
  sig { returns(::String) }
  def sgr; end

  class << self
    # All available colors by name
    #
    # source://cli-ui//lib/cli/ui/color.rb#100
    sig { returns(T::Array[::Symbol]) }
    def available; end

    # Looks up a color code by name
    #
    # ==== Raises
    # Raises a InvalidColorName if the color is not available
    # You likely need to add it to the +MAP+ or you made a typo
    #
    # ==== Returns
    # Returns a color code
    #
    # source://cli-ui//lib/cli/ui/color.rb#91
    sig { params(name: T.any(::String, ::Symbol)).returns(::CLI::UI::Color) }
    def lookup(name); end
  end
end

# default blue is low-contrast against black in some default terminal color scheme
#
# source://cli-ui//lib/cli/ui/color.rb#37
CLI::UI::Color::BLUE = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#41
CLI::UI::Color::BOLD = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#39
CLI::UI::Color::CYAN = T.let(T.unsafe(nil), CLI::UI::Color)

# 240 is very dark gray; 255 is very light gray. 244 is somewhat dark.
#
# source://cli-ui//lib/cli/ui/color.rb#45
CLI::UI::Color::GRAY = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#34
CLI::UI::Color::GREEN = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#61
class CLI::UI::Color::InvalidColorName < ::ArgumentError
  # source://cli-ui//lib/cli/ui/color.rb#65
  sig { params(name: ::Symbol).void }
  def initialize(name); end

  # source://cli-ui//lib/cli/ui/color.rb#71
  sig { returns(::String) }
  def message; end
end

# source://cli-ui//lib/cli/ui/color.rb#38
CLI::UI::Color::MAGENTA = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#49
CLI::UI::Color::MAP = T.let(T.unsafe(nil), Hash)

# Using color 214 from the 256-color palette for a more distinct orange
#
# source://cli-ui//lib/cli/ui/color.rb#47
CLI::UI::Color::ORANGE = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#33
CLI::UI::Color::RED = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#40
CLI::UI::Color::RESET = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#42
CLI::UI::Color::WHITE = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/color.rb#35
CLI::UI::Color::YELLOW = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui.rb#31
CLI::UI::Colorable = T.type_alias { T.any(::CLI::UI::Color, ::String, ::Symbol) }

# source://cli-ui//lib/cli/ui/formatter.rb#9
class CLI::UI::Formatter
  # Initialize a formatter with text.
  #
  # ===== Attributes
  #
  # * +text+ - the text to format
  #
  # source://cli-ui//lib/cli/ui/formatter.rb#87
  sig { params(text: ::String).void }
  def initialize(text); end

  # Format the text using a map.
  #
  # ===== Attributes
  #
  # * +sgr_map+ - the mapping of the formattings. Defaults to +SGR_MAP+
  #
  # ===== Options
  #
  # * +:enable_color+ - enable color output? Default is true unless output is redirected
  #
  # source://cli-ui//lib/cli/ui/formatter.rb#103
  sig { params(sgr_map: T::Hash[::String, ::String], enable_color: T::Boolean).returns(::String) }
  def format(sgr_map = T.unsafe(nil), enable_color: T.unsafe(nil)); end

  private

  # source://cli-ui//lib/cli/ui/formatter.rb#129
  sig do
    params(
      text: ::String,
      fmt: T::Array[T.any(::CLI::UI::Formatter::LITERAL_BRACES, ::String)],
      sgr_map: T::Hash[::String, ::String]
    ).returns(::String)
  end
  def apply_format(text, fmt, sgr_map); end

  # source://cli-ui//lib/cli/ui/formatter.rb#211
  sig { params(text: ::String, stack: T::Array[T.any(::CLI::UI::Formatter::LITERAL_BRACES, ::String)]).void }
  def emit(text, stack); end

  # source://cli-ui//lib/cli/ui/formatter.rb#191
  sig do
    params(
      sc: ::StringScanner,
      stack: T::Array[T.any(::CLI::UI::Formatter::LITERAL_BRACES, ::String)]
    ).returns(T::Array[T.any(::CLI::UI::Formatter::LITERAL_BRACES, ::String)])
  end
  def parse_body(sc, stack = T.unsafe(nil)); end

  # source://cli-ui//lib/cli/ui/formatter.rb#147
  sig do
    params(
      sc: ::StringScanner,
      stack: T::Array[T.any(::CLI::UI::Formatter::LITERAL_BRACES, ::String)]
    ).returns(T::Array[T.any(::CLI::UI::Formatter::LITERAL_BRACES, ::String)])
  end
  def parse_expr(sc, stack); end
end

# source://cli-ui//lib/cli/ui/formatter.rb#42
CLI::UI::Formatter::BEGIN_EXPR = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/formatter.rb#57
CLI::UI::Formatter::DISCARD_BRACES = T.let(T.unsafe(nil), Range)

# source://cli-ui//lib/cli/ui/formatter.rb#43
CLI::UI::Formatter::END_EXPR = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/formatter.rb#63
class CLI::UI::Formatter::FormatError < ::StandardError
  # source://cli-ui//lib/cli/ui/formatter.rb#73
  sig { params(message: ::String, input: ::String, index: ::Integer).void }
  def initialize(message, input, index); end

  # source://cli-ui//lib/cli/ui/formatter.rb#70
  sig { returns(::Integer) }
  def index; end

  # @return [Integer]
  #
  # source://cli-ui//lib/cli/ui/formatter.rb#70
  def index=(_arg0); end

  # source://cli-ui//lib/cli/ui/formatter.rb#67
  sig { returns(::String) }
  def input; end

  # @return [String]
  #
  # source://cli-ui//lib/cli/ui/formatter.rb#67
  def input=(_arg0); end
end

# source://cli-ui//lib/cli/ui/formatter.rb#59
class CLI::UI::Formatter::LITERAL_BRACES; end

# source://cli-ui//lib/cli/ui/formatter.rb#48
CLI::UI::Formatter::SCAN_BODY = T.let(T.unsafe(nil), Regexp)

# source://cli-ui//lib/cli/ui/formatter.rb#46
CLI::UI::Formatter::SCAN_FUNCNAME = T.let(T.unsafe(nil), Regexp)

# source://cli-ui//lib/cli/ui/formatter.rb#47
CLI::UI::Formatter::SCAN_GLYPH = T.let(T.unsafe(nil), Regexp)

# source://cli-ui//lib/cli/ui/formatter.rb#45
CLI::UI::Formatter::SCAN_WIDGET = T.let(T.unsafe(nil), Regexp)

# Available mappings of formattings
# To use any of them, you can use {{<key>:<string>}}
# There are presentational (colours and formatters)
# and semantic (error, info, command) formatters available
#
# source://cli-ui//lib/cli/ui/formatter.rb#17
CLI::UI::Formatter::SGR_MAP = T.let(T.unsafe(nil), Hash)

# source://cli-ui//lib/cli/ui/formatter.rb#61
CLI::UI::Formatter::Stack = T.type_alias { T::Array[T.any(::CLI::UI::Formatter::LITERAL_BRACES, ::String)] }

# source://cli-ui//lib/cli/ui/frame/frame_stack.rb#6
module CLI::UI::Frame
  class << self
    # Closes a frame
    # Automatically called for a block-form +open+
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - The color of the frame. Defaults to nil
    # * +:elapsed+ - How long did the frame take? Defaults to nil
    # * +frame_style+ - The frame style to use for this frame.  Defaults to nil
    # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,
    #   or under Sorbet, IO or StringIO. Defaults to $stdout.
    #
    # ==== Example
    #
    #   CLI::UI::Frame.close('Close')
    #
    # Default Output:
    #   â”—â”â” Close â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    #
    # ==== Raises
    #
    # MUST be inside an open frame or it raises a +UnnestedFrameException+
    #
    # @raise [UnnestedFrameException]
    #
    # source://cli-ui//lib/cli/ui/frame.rb#230
    sig do
      params(
        text: T.nilable(::String),
        color: T.nilable(T.any(::CLI::UI::Color, ::String, ::Symbol)),
        elapsed: T.nilable(::Numeric),
        frame_style: T.nilable(T.any(::CLI::UI::Frame::FrameStyle, ::String, ::Symbol)),
        to: T.any(::IO, ::StringIO)
      ).void
    end
    def close(text, color: T.unsafe(nil), elapsed: T.unsafe(nil), frame_style: T.unsafe(nil), to: T.unsafe(nil)); end

    # Adds a divider in a frame
    # Used to separate information within a single frame
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - The color of the frame. Defaults to +DEFAULT_FRAME_COLOR+
    # * +frame_style+ - The frame style to use for this frame
    # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,
    #   or under Sorbet, IO or StringIO. Defaults to $stdout.
    #
    # ==== Example
    #
    #   CLI::UI::Frame.open('Open') { CLI::UI::Frame.divider('Divider') }
    #
    # Default Output:
    #   â”â”â” Open â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    #   â”£â”â” Divider â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    #   â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    #
    # ==== Raises
    #
    # MUST be inside an open frame or it raises a +UnnestedFrameException+
    #
    # @raise [UnnestedFrameException]
    #
    # source://cli-ui//lib/cli/ui/frame.rb#180
    sig do
      params(
        text: T.nilable(::String),
        color: T.nilable(T.any(::CLI::UI::Color, ::String, ::Symbol)),
        frame_style: T.nilable(T.any(::CLI::UI::Frame::FrameStyle, ::String, ::Symbol)),
        to: T.any(::IO, ::StringIO)
      ).void
    end
    def divider(text, color: T.unsafe(nil), frame_style: T.unsafe(nil), to: T.unsafe(nil)); end

    # source://cli-ui//lib/cli/ui/frame.rb#18
    sig { returns(::CLI::UI::Frame::FrameStyle) }
    def frame_style; end

    # Set the default frame style.
    #
    # Raises ArgumentError if +frame_style+ is not valid
    #
    # ==== Attributes
    #
    # * +symbol+ or +FrameStyle+ - the default frame style to use for frames
    #
    # source://cli-ui//lib/cli/ui/frame.rb#31
    sig { params(frame_style: T.any(::CLI::UI::Frame::FrameStyle, ::String, ::Symbol)).void }
    def frame_style=(frame_style); end

    # Opens a new frame. Can be nested
    # Can be invoked in two ways: block and blockless
    # * In block form, the frame is closed automatically when the block returns
    # * In blockless form, caller MUST call +Frame.close+ when the frame is logically done
    # * Blockless form is strongly discouraged in cases where block form can be made to work
    #
    # https://user-images.githubusercontent.com/3074765/33799861-cb5dcb5c-dd01-11e7-977e-6fad38cee08c.png
    #
    # The return value of the block determines if the block is a "success" or a "failure"
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - The color of the frame. Defaults to +DEFAULT_FRAME_COLOR+
    # * +:failure_text+ - If the block failed, what do we output? Defaults to nil
    # * +:success_text+ - If the block succeeds, what do we output? Defaults to nil
    # * +:timing+ - How long did the frame content take? Invalid for blockless. Defaults to true for the block form
    # * +frame_style+ - The frame style to use for this frame
    # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,
    #   or under Sorbet, IO or StringIO. Defaults to $stdout.
    #
    # ==== Example
    #
    # ===== Block Form (Assumes +CLI::UI::StdoutRouter.enable+ has been called)
    #
    #   CLI::UI::Frame.open('Open') { puts 'hi' }
    #
    # Default Output:
    #   â”â”â” Open â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    #   â”ƒ hi
    #   â”—â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â” (0.0s) â”â”
    #
    # ===== Blockless Form
    #
    #   CLI::UI::Frame.open('Open')
    #
    # Default Output:
    #   â”â”â” Open â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    #
    # source://cli-ui//lib/cli/ui/frame.rb#90
    sig do
      type_parameters(:T)
        .params(
          text: ::String,
          color: T.any(::CLI::UI::Color, ::String, ::Symbol),
          failure_text: T.nilable(::String),
          success_text: T.nilable(::String),
          timing: T.any(::Numeric, T::Boolean),
          frame_style: T.any(::CLI::UI::Frame::FrameStyle, ::String, ::Symbol),
          to: T.any(::IO, ::StringIO),
          block: T.nilable(T.proc.returns(T.type_parameter(:T)))
        ).returns(T.nilable(T.type_parameter(:T)))
    end
    def open(text, color: T.unsafe(nil), failure_text: T.unsafe(nil), success_text: T.unsafe(nil), timing: T.unsafe(nil), frame_style: T.unsafe(nil), to: T.unsafe(nil), &block); end

    # Determines the prefix of a frame entry taking multi-nested frames into account
    #
    # ==== Options
    #
    # * +:color+ - The color of the prefix. Defaults to +Thread.current[:cliui_frame_color_override]+
    #
    # source://cli-ui//lib/cli/ui/frame.rb#251
    sig { params(color: T.nilable(T.any(::CLI::UI::Color, ::String, ::Symbol))).returns(::String) }
    def prefix(color: T.unsafe(nil)); end

    # The width of a prefix given the number of Frames in the stack
    #
    # source://cli-ui//lib/cli/ui/frame.rb#273
    sig { returns(::Integer) }
    def prefix_width; end

    # Override a color for a given thread.
    #
    # ==== Attributes
    #
    # * +color+ - The color to override to
    #
    # source://cli-ui//lib/cli/ui/frame.rb#292
    sig do
      type_parameters(:T)
        .params(
          color: T.any(::CLI::UI::Color, ::String, ::Symbol),
          block: T.proc.returns(T.type_parameter(:T))
        ).returns(T.type_parameter(:T))
    end
    def with_frame_color_override(color, &block); end

    private

    # If timing is:
    #   Numeric: return it
    #   false: return nil
    #   true: defaults to Time.new
    #
    # source://cli-ui//lib/cli/ui/frame.rb#307
    sig { params(start: ::Time, timing: T.any(::Numeric, T::Boolean)).returns(T.nilable(::Numeric)) }
    def elapsed(start, timing); end
  end
end

# source://cli-ui//lib/cli/ui/frame.rb#12
CLI::UI::Frame::DEFAULT_FRAME_COLOR = T.let(T.unsafe(nil), CLI::UI::Color)

# source://cli-ui//lib/cli/ui/frame/frame_stack.rb#7
module CLI::UI::Frame::FrameStack
  class << self
    # Fetch all items off the frame stack
    #
    # source://cli-ui//lib/cli/ui/frame/frame_stack.rb#32
    sig { returns(T::Array[::CLI::UI::Frame::FrameStack::StackItem]) }
    def items; end

    # Removes and returns the last stack item off the stack
    #
    # source://cli-ui//lib/cli/ui/frame/frame_stack.rb#72
    sig { returns(T.nilable(::CLI::UI::Frame::FrameStack::StackItem)) }
    def pop; end

    # Push a new item onto the frame stack.
    #
    # Either an item or a :color/:style pair should be pushed onto the stack.
    #
    # ==== Attributes
    #
    # * +item+ a +StackItem+ to push onto the stack. Defaults to nil
    #
    # ==== Options
    #
    # * +:color+ the color of the new stack item. Defaults to nil
    # * +:style+ the style of the new stack item. Defaults to nil
    #
    # ==== Raises
    #
    # If both an item and a color/style pair are given, raises an +ArgumentError+
    # If the given item is not a +StackItem+, raises an +ArgumentError+
    #
    # source://cli-ui//lib/cli/ui/frame/frame_stack.rb#62
    sig do
      params(
        item: T.nilable(::CLI::UI::Frame::FrameStack::StackItem),
        color: T.nilable(::CLI::UI::Color),
        style: T.nilable(::CLI::UI::Frame::FrameStyle)
      ).void
    end
    def push(item = T.unsafe(nil), color: T.unsafe(nil), style: T.unsafe(nil)); end
  end
end

# source://cli-ui//lib/cli/ui/frame/frame_stack.rb#8
class CLI::UI::Frame::FrameStack::StackItem
  # source://cli-ui//lib/cli/ui/frame/frame_stack.rb#21
  sig do
    params(
      color_name: T.any(::CLI::UI::Color, ::String, ::Symbol),
      style_name: T.any(::CLI::UI::Frame::FrameStyle, ::String, ::Symbol)
    ).void
  end
  def initialize(color_name, style_name); end

  # source://cli-ui//lib/cli/ui/frame/frame_stack.rb#12
  sig { returns(::CLI::UI::Color) }
  def color; end

  # source://cli-ui//lib/cli/ui/frame/frame_stack.rb#15
  sig { returns(::CLI::UI::Frame::FrameStyle) }
  def frame_style; end
end

# @abstract Subclasses must implement the `abstract` methods below.
#
# source://cli-ui//lib/cli/ui/frame/frame_style.rb#9
module CLI::UI::Frame::FrameStyle
  include ::Kernel

  abstract!

  # Draws the "Close" line for this frame style
  #
  # ==== Attributes
  #
  # * +text+ - (required) the text/title to output in the frame
  #
  # ==== Options
  #
  # * +:color+ - (required) The color of the frame.
  # * +:right_text+ - Text to print at the right of the line. Defaults to nil
  #
  # @abstract
  #
  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#78
  sig { abstract.params(text: ::String, color: ::CLI::UI::Color, right_text: T.nilable(::String)).returns(::String) }
  def close(text, color:, right_text: T.unsafe(nil)); end

  # Draws a "divider" line for the current frame style
  #
  # ==== Attributes
  #
  # * +text+ - (required) the text/title to output in the frame
  #
  # ==== Options
  #
  # * +:color+ - (required) The color of the frame.
  #
  # @abstract
  #
  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#91
  sig { abstract.params(text: ::String, color: ::CLI::UI::Color).returns(::String) }
  def divider(text, color:); end

  # Returns the character(s) that should be printed at the beginning
  # of lines inside this frame
  #
  # @abstract
  #
  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#45
  sig { abstract.returns(::String) }
  def prefix; end

  # Returns the printing width of the prefix
  #
  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#49
  sig { returns(::Integer) }
  def prefix_width; end

  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#94
  sig { params(x: ::Integer, str: ::String).returns(::String) }
  def print_at_x(x, str); end

  # Draws the "Open" line for this frame style
  #
  # ==== Attributes
  #
  # * +text+ - (required) the text/title to output in the frame
  #
  # ==== Options
  #
  # * +:color+ - (required) The color of the frame.
  #
  # @abstract
  #
  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#64
  sig { abstract.params(text: ::String, color: ::CLI::UI::Color).returns(::String) }
  def start(text, color:); end

  # @abstract
  #
  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#40
  sig { abstract.returns(::Symbol) }
  def style_name; end

  class << self
    # Lookup a frame style via its name
    #
    # ==== Attributes
    #
    # * +symbol+ - frame style name to lookup
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style.rb#32
    sig { params(name: T.any(::String, ::Symbol)).returns(::CLI::UI::Frame::FrameStyle) }
    def lookup(name); end
  end
end

# source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#8
module CLI::UI::Frame::FrameStyle::Box
  extend ::CLI::UI::Frame::FrameStyle

  class << self
    # Draws the "Close" line for this frame style
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - (required) The color of the frame.
    # * +:right_text+ - Text to print at the right of the line. Defaults to nil
    #
    # ==== Output:
    #
    #   â”—â”â” Close â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#84
    sig { override.params(text: ::String, color: ::CLI::UI::Color, right_text: T.nilable(::String)).returns(::String) }
    def close(text, color:, right_text: T.unsafe(nil)); end

    # Draws a "divider" line for the current frame style
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - (required) The color of the frame.
    #
    # ==== Output:
    #
    #   â”£â”â” Divider â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#64
    sig { override.params(text: ::String, color: ::CLI::UI::Color).returns(::String) }
    def divider(text, color:); end

    # source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#26
    sig { override.returns(::String) }
    def prefix; end

    # Draws the "Open" line for this frame style
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - (required) The color of the frame.
    #
    # ==== Output:
    #
    #   â”â”â” Open â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#45
    sig { override.params(text: ::String, color: ::CLI::UI::Color).returns(::String) }
    def start(text, color:); end

    # source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#21
    sig { override.returns(::Symbol) }
    def style_name; end

    private

    # source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#93
    sig do
      params(
        text: ::String,
        color: ::CLI::UI::Color,
        first: ::String,
        right_text: T.nilable(::String)
      ).returns(::String)
    end
    def edge(text, color:, first:, right_text: T.unsafe(nil)); end
  end
end

# source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#15
CLI::UI::Frame::FrameStyle::Box::BOTTOM_LEFT = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#13
CLI::UI::Frame::FrameStyle::Box::DIVIDER = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#12
CLI::UI::Frame::FrameStyle::Box::HORIZONTAL = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#14
CLI::UI::Frame::FrameStyle::Box::TOP_LEFT = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/box.rb#11
CLI::UI::Frame::FrameStyle::Box::VERTICAL = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#8
module CLI::UI::Frame::FrameStyle::Bracket
  extend ::CLI::UI::Frame::FrameStyle

  class << self
    # Draws the "Close" line for this frame style
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - (required) The color of the frame.
    # * +:right_text+ - Text to print at the right of the line. Defaults to nil
    #
    # ==== Output:
    #
    #   â”—â”â” Close
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#84
    sig { override.params(text: ::String, color: ::CLI::UI::Color, right_text: T.nilable(::String)).returns(::String) }
    def close(text, color:, right_text: T.unsafe(nil)); end

    # Draws a "divider" line for the current frame style
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - (required) The color of the frame.
    #
    # ==== Output:
    #
    #   â”£â”â” Divider
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#64
    sig { override.params(text: ::String, color: ::CLI::UI::Color).returns(::String) }
    def divider(text, color:); end

    # source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#26
    sig { override.returns(::String) }
    def prefix; end

    # Draws the "Open" line for this frame style
    #
    # ==== Attributes
    #
    # * +text+ - (required) the text/title to output in the frame
    #
    # ==== Options
    #
    # * +:color+ - (required) The color of the frame.
    #
    # ==== Output
    #
    #   â”â”â” Open
    #
    # source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#45
    sig { override.params(text: ::String, color: ::CLI::UI::Color).returns(::String) }
    def start(text, color:); end

    # source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#21
    sig { override.returns(::Symbol) }
    def style_name; end

    private

    # source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#93
    sig do
      params(
        text: ::String,
        color: ::CLI::UI::Color,
        first: ::String,
        right_text: T.nilable(::String)
      ).returns(::String)
    end
    def edge(text, color:, first:, right_text: T.unsafe(nil)); end
  end
end

# source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#15
CLI::UI::Frame::FrameStyle::Bracket::BOTTOM_LEFT = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#13
CLI::UI::Frame::FrameStyle::Bracket::DIVIDER = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#12
CLI::UI::Frame::FrameStyle::Bracket::HORIZONTAL = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#14
CLI::UI::Frame::FrameStyle::Bracket::TOP_LEFT = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style/bracket.rb#11
CLI::UI::Frame::FrameStyle::Bracket::VERTICAL = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/frame/frame_style.rb#98
class CLI::UI::Frame::FrameStyle::InvalidFrameStyleName < ::ArgumentError
  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#102
  sig { params(name: T.any(::String, ::Symbol)).void }
  def initialize(name); end

  # source://cli-ui//lib/cli/ui/frame/frame_style.rb#108
  sig { returns(::String) }
  def message; end
end

# source://cli-ui//lib/cli/ui/frame/frame_style.rb#18
CLI::UI::Frame::FrameStyle::MAP = T.let(T.unsafe(nil), Hash)

# source://cli-ui//lib/cli/ui/frame.rb#11
class CLI::UI::Frame::UnnestedFrameException < ::StandardError; end

# source://cli-ui//lib/cli/ui.rb#32
CLI::UI::FrameStylable = T.type_alias { T.any(::CLI::UI::Frame::FrameStyle, ::String, ::Symbol) }

# source://cli-ui//lib/cli/ui/glyph.rb#8
class CLI::UI::Glyph
  # Creates a new glyph
  #
  # ==== Attributes
  #
  # * +handle+ - The handle in the +MAP+ constant
  # * +codepoint+ - The codepoint used to create the glyph (e.g. +0x2717+ for a ballot X)
  # * +plain+ - A fallback plain string to be used in case glyphs are disabled
  # * +color+ - What color to output the glyph. Check +CLI::UI::Color+ for options.
  #
  # source://cli-ui//lib/cli/ui/glyph.rb#47
  sig do
    params(
      handle: ::String,
      codepoint: T.any(::Integer, T::Array[::Integer]),
      plain: ::String,
      color: ::CLI::UI::Color
    ).void
  end
  def initialize(handle, codepoint, plain, color); end

  # @return [String]
  #
  # source://cli-ui//lib/cli/ui/glyph.rb#29
  def char; end

  # source://cli-ui//lib/cli/ui/glyph.rb#32
  sig { returns(T.any(::Integer, T::Array[::Integer])) }
  def codepoint; end

  # source://cli-ui//lib/cli/ui/glyph.rb#35
  sig { returns(::CLI::UI::Color) }
  def color; end

  # @return [String]
  #
  # source://cli-ui//lib/cli/ui/glyph.rb#29
  def fmt; end

  # source://cli-ui//lib/cli/ui/glyph.rb#29
  sig { returns(::String) }
  def handle; end

  # @return [String]
  #
  # source://cli-ui//lib/cli/ui/glyph.rb#29
  def to_s; end

  class << self
    # All available glyphs by name
    #
    # source://cli-ui//lib/cli/ui/glyph.rb#92
    sig { returns(T::Array[::String]) }
    def available; end

    # Looks up a glyph by name
    #
    # ==== Raises
    # Raises a InvalidGlyphHandle if the glyph is not available
    # You likely need to create it with +.new+ or you made a typo
    #
    # ==== Returns
    # Returns a terminal output-capable string
    #
    # source://cli-ui//lib/cli/ui/glyph.rb#83
    sig { params(name: ::String).returns(::CLI::UI::Glyph) }
    def lookup(name); end
  end
end

# Bug emoji (ðŸ›)
#
# source://cli-ui//lib/cli/ui/glyph.rb#65
CLI::UI::Glyph::BUG = T.let(T.unsafe(nil), CLI::UI::Glyph)

# GREEN CHECK MARK (âœ“)
#
# source://cli-ui//lib/cli/ui/glyph.rb#63
CLI::UI::Glyph::CHECK = T.let(T.unsafe(nil), CLI::UI::Glyph)

# RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK (Â»)
#
# source://cli-ui//lib/cli/ui/glyph.rb#66
CLI::UI::Glyph::CHEVRON = T.let(T.unsafe(nil), CLI::UI::Glyph)

# HOURGLASS (â§–)
#
# source://cli-ui//lib/cli/ui/glyph.rb#67
CLI::UI::Glyph::HOURGLASS = T.let(T.unsafe(nil), CLI::UI::Glyph)

# BLUE MATHEMATICAL SCRIPT SMALL i (ð’¾)
#
# source://cli-ui//lib/cli/ui/glyph.rb#61
CLI::UI::Glyph::INFO = T.let(T.unsafe(nil), CLI::UI::Glyph)

# source://cli-ui//lib/cli/ui/glyph.rb#11
class CLI::UI::Glyph::InvalidGlyphHandle < ::ArgumentError
  # source://cli-ui//lib/cli/ui/glyph.rb#15
  sig { params(handle: ::String).void }
  def initialize(handle); end

  # source://cli-ui//lib/cli/ui/glyph.rb#21
  sig { returns(::String) }
  def message; end
end

# Mapping of glyphs to terminal output
#
# source://cli-ui//lib/cli/ui/glyph.rb#59
CLI::UI::Glyph::MAP = T.let(T.unsafe(nil), Hash)

# BLUE QUESTION MARK (?)
#
# source://cli-ui//lib/cli/ui/glyph.rb#62
CLI::UI::Glyph::QUESTION = T.let(T.unsafe(nil), CLI::UI::Glyph)

# YELLOW SMALL STAR (â­‘)
#
# source://cli-ui//lib/cli/ui/glyph.rb#60
CLI::UI::Glyph::STAR = T.let(T.unsafe(nil), CLI::UI::Glyph)

# WARNING SIGN + VARIATION SELECTOR 16 (âš ï¸ )
#
# source://cli-ui//lib/cli/ui/glyph.rb#68
CLI::UI::Glyph::WARNING = T.let(T.unsafe(nil), CLI::UI::Glyph)

# RED BALLOT X (âœ—)
#
# source://cli-ui//lib/cli/ui/glyph.rb#64
CLI::UI::Glyph::X = T.let(T.unsafe(nil), CLI::UI::Glyph)

# source://cli-ui//lib/cli/ui.rb#33
CLI::UI::IOLike = T.type_alias { T.any(::IO, ::StringIO) }

# source://cli-ui//lib/cli/ui/os.rb#8
class CLI::UI::OS
  # source://cli-ui//lib/cli/ui/os.rb#12
  sig { params(emoji: T::Boolean, color_prompt: T::Boolean, arrow_keys: T::Boolean, shift_cursor: T::Boolean).void }
  def initialize(emoji: T.unsafe(nil), color_prompt: T.unsafe(nil), arrow_keys: T.unsafe(nil), shift_cursor: T.unsafe(nil)); end

  # source://cli-ui//lib/cli/ui/os.rb#35
  sig { returns(T::Boolean) }
  def shift_cursor_back_on_horizontal_absolute?; end

  # source://cli-ui//lib/cli/ui/os.rb#30
  sig { returns(T::Boolean) }
  def suggest_arrow_keys?; end

  # source://cli-ui//lib/cli/ui/os.rb#25
  sig { returns(T::Boolean) }
  def use_color_prompt?; end

  # source://cli-ui//lib/cli/ui/os.rb#20
  sig { returns(T::Boolean) }
  def use_emoji?; end

  class << self
    # source://cli-ui//lib/cli/ui/os.rb#43
    sig { returns(::CLI::UI::OS) }
    def current; end
  end
end

# source://cli-ui//lib/cli/ui/os.rb#60
CLI::UI::OS::LINUX = T.let(T.unsafe(nil), CLI::UI::OS)

# source://cli-ui//lib/cli/ui/os.rb#59
CLI::UI::OS::MAC = T.let(T.unsafe(nil), CLI::UI::OS)

# source://cli-ui//lib/cli/ui/os.rb#61
CLI::UI::OS::WINDOWS = T.let(T.unsafe(nil), CLI::UI::OS)

# source://cli-ui//lib/cli/ui/printer.rb#8
class CLI::UI::Printer
  class << self
    # Print a message to a stream with common utilities.
    # Allows overriding the color, encoding, and target stream.
    # By default, it formats the string using CLI:UI and rescues common stream errors.
    #
    # ==== Attributes
    #
    # * +msg+ - (required) the string to output. Can be frozen.
    #
    # ==== Options
    #
    # * +:frame_color+ - Override the frame color. Defaults to nil.
    # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with a puts method. Defaults to $stdout.
    # * +:encoding+ - Force the output to be in a certain encoding. Defaults to UTF-8.
    # * +:format+ - Whether to format the string using CLI::UI.fmt. Defaults to true.
    # * +:graceful+ - Whether to gracefully ignore common I/O errors. Defaults to true.
    # * +:wrap+ - Whether to wrap text at word boundaries to terminal width. Defaults to true.
    #
    # ==== Returns
    # Returns whether the message was successfully printed,
    # which can be useful if +:graceful+ is set to true.
    #
    # ==== Example
    #
    #   CLI::UI::Printer.puts('{{x}} Ouch', to: $stderr)
    #
    # source://cli-ui//lib/cli/ui/printer.rb#50
    sig do
      params(
        msg: ::String,
        frame_color: T.nilable(T.any(::CLI::UI::Color, ::String, ::Symbol)),
        to: T.any(::IO, ::StringIO),
        encoding: T.nilable(::Encoding),
        format: T::Boolean,
        graceful: T::Boolean,
        wrap: T::Boolean
      ).returns(T::Boolean)
    end
    def puts(msg, frame_color: T.unsafe(nil), to: T.unsafe(nil), encoding: T.unsafe(nil), format: T.unsafe(nil), graceful: T.unsafe(nil), wrap: T.unsafe(nil)); end
  end
end

# source://cli-ui//lib/cli/ui/progress.rb#8
class CLI::UI::Progress
  # Initialize a progress bar. Typically used in a +Progress.progress+ block
  #
  # ==== Options
  #
  # * +:title+ - The title of the progress bar
  # * +:width+ - The width of the terminal
  #
  # source://cli-ui//lib/cli/ui/progress.rb#74
  sig { params(title: T.nilable(::String), width: ::Integer).void }
  def initialize(title = T.unsafe(nil), width: T.unsafe(nil)); end

  # Set the progress of the bar. Typically used in a +Progress.progress+ block
  #
  # ==== Options
  # One of the follow can be used, but not both together
  #
  # * +:percent+ - Increment progress by a specific percent amount
  # * +:set_percent+ - Set progress to a specific percent
  #
  # *Note:* The +:percent+ and +:set_percent must be between 0.00 and 1.0
  #
  # @raise [ArgumentError]
  #
  # source://cli-ui//lib/cli/ui/progress.rb#91
  sig { params(percent: T.nilable(::Numeric), set_percent: T.nilable(::Numeric)).void }
  def tick(percent: T.unsafe(nil), set_percent: T.unsafe(nil)); end

  # Format the progress bar to be printed to terminal
  #
  # source://cli-ui//lib/cli/ui/progress.rb#118
  sig { returns(::String) }
  def to_s; end

  # Update the progress bar title
  #
  # ==== Attributes
  #
  # * +new_title+ - title to change the progress bar to
  #
  # source://cli-ui//lib/cli/ui/progress.rb#111
  sig { params(new_title: ::String).void }
  def update_title(new_title); end

  class << self
    # Add a progress bar to the terminal output
    #
    # https://user-images.githubusercontent.com/3074765/33799794-cc4c940e-dd00-11e7-9bdc-90f77ec9167c.gif
    #
    # ==== Example Usage:
    #
    # Set the percent to X
    #   CLI::UI::Progress.progress do |bar|
    #     bar.tick(set_percent: percent)
    #   end
    #
    # Increase the percent by 1 percent
    #   CLI::UI::Progress.progress do |bar|
    #     bar.tick
    #   end
    #
    # Increase the percent by X
    #   CLI::UI::Progress.progress do |bar|
    #     bar.tick(percent: 0.05)
    #   end
    #
    # Update the title
    #   CLI::UI::Progress.progress('Title') do |bar|
    #     bar.tick(percent: 0.05)
    #     bar.update_title('New title')
    #   end
    #
    # source://cli-ui//lib/cli/ui/progress.rb#54
    sig do
      type_parameters(:T)
        .params(
          title: T.nilable(::String),
          width: ::Integer,
          block: T.proc.params(bar: ::CLI::UI::Progress).returns(T.type_parameter(:T))
        ).returns(T.type_parameter(:T))
    end
    def progress(title = T.unsafe(nil), width: T.unsafe(nil), &block); end
  end
end

# A Cyan filled block
#
# source://cli-ui//lib/cli/ui/progress.rb#12
CLI::UI::Progress::FILLED_BAR = T.let(T.unsafe(nil), String)

# A bright white block
#
# source://cli-ui//lib/cli/ui/progress.rb#14
CLI::UI::Progress::UNFILLED_BAR = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/prompt.rb#15
module CLI::UI::Prompt
  class << self
    # Present the user with a message and wait for any key to be pressed, returning the pressed key.
    #
    # ==== Example Usage:
    #
    #   CLI::UI::Prompt.any_key # Press any key to continue...
    #
    #   CLI::UI::Prompt.any_key('Press RETURN to continue...') # Then check if that's what they pressed
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#212
    sig { params(prompt: ::String).returns(T.nilable(::String)) }
    def any_key(prompt = T.unsafe(nil)); end

    # Ask a user a question with either free form answer or a set of answers (multiple choice)
    # Can use arrows, y/n, numbers (1/2), and vim bindings to control multiple choice selection
    # Do not use this method for yes/no questions. Use +confirm+
    #
    # * Handles free form answers (options are nil)
    # * Handles default answers for free form text
    # * Handles file auto completion for file input
    # * Handles interactively choosing answers using +InteractiveOptions+
    #
    # https://user-images.githubusercontent.com/3074765/33799822-47f23302-dd01-11e7-82f3-9072a5a5f611.png
    #
    # ==== Attributes
    #
    # * +question+ - (required) The question to ask the user
    #
    # ==== Options
    #
    # * +:options+ - Options that the user may select from. Will use +InteractiveOptions+ to do so.
    # * +:default+ - The default answer to the question (e.g. they just press enter and don't input anything)
    # * +:is_file+ - Tells the input to use file auto-completion (tab completion)
    # * +:allow_empty+ - Allows the answer to be empty
    # * +:multiple+ - Allow multiple options to be selected
    # * +:filter_ui+ - Enable option filtering (default: true)
    # * +:select_ui+ - Enable long-form option selection (default: true)
    #
    # Note:
    # * +:options+ or providing a +Block+ conflicts with +:default+ and +:is_file+,
    #              you cannot set options with either of these keywords
    # * +:default+ conflicts with +:allow_empty:, you cannot set these together
    # * +:options+ conflicts with providing a +Block+ , you may only set one
    # * +:multiple+ can only be used with +:options+ or a +Block+; it is ignored, otherwise.
    #
    # ==== Block (optional)
    #
    # * A Proc that provides a +OptionsHandler+ and uses the public +:option+ method to add options and their
    #   respective handlers
    #
    # ==== Return Value
    #
    # * If a +Block+ was not provided, the selected option or response to the free form question will be returned
    # * If a +Block+ was provided, the evaluated value of the +Block+ will be returned
    #
    # ==== Example Usage:
    #
    # Free form question
    #   CLI::UI::Prompt.ask('What color is the sky?')
    #
    # Free form question with a file answer
    #   CLI::UI::Prompt.ask('Where is your Gemfile located?', is_file: true)
    #
    # Free form question with a default answer
    #   CLI::UI::Prompt.ask('What color is the sky?', default: 'blue')
    #
    # Free form question when the answer can be empty
    #   CLI::UI::Prompt.ask('What is your opinion on this question?', allow_empty: true)
    #
    # Interactive (multiple choice) question
    #   CLI::UI::Prompt.ask('What kind of project is this?', options: %w(rails go ruby python))
    #
    # Interactive (multiple choice) question with defined handlers
    #   CLI::UI::Prompt.ask('What kind of project is this?') do |handler|
    #     handler.option('rails')  { |selection| selection }
    #     handler.option('go')     { |selection| selection }
    #     handler.option('ruby')   { |selection| selection }
    #     handler.option('python') { |selection| selection }
    #   end
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#118
    sig do
      params(
        question: ::String,
        options: T.nilable(T::Array[::String]),
        default: T.nilable(T.any(::String, T::Array[::String])),
        is_file: T::Boolean,
        allow_empty: T::Boolean,
        multiple: T::Boolean,
        filter_ui: T::Boolean,
        select_ui: T::Boolean,
        options_proc: T.nilable(T.proc.params(handler: ::CLI::UI::Prompt::OptionsHandler).void)
      ).returns(T.any(::String, T::Array[::String]))
    end
    def ask(question, options: T.unsafe(nil), default: T.unsafe(nil), is_file: T.unsafe(nil), allow_empty: T.unsafe(nil), multiple: T.unsafe(nil), filter_ui: T.unsafe(nil), select_ui: T.unsafe(nil), &options_proc); end

    # Asks the user for a single-line answer, without displaying the characters while typing.
    # Typically used for password prompts
    #
    # ==== Return Value
    #
    # The password, without a trailing newline.
    # If the user simply presses "Enter" without typing any password, this will return an empty string.
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#169
    sig { params(question: ::String).returns(::String) }
    def ask_password(question); end

    # Asks the user a yes/no question.
    # Can use arrows, y/n, numbers (1/2), and vim bindings to control
    #
    # ==== Example Usage:
    #
    # Confirmation question
    #   CLI::UI::Prompt.confirm('Is the sky blue?')
    #
    #   CLI::UI::Prompt.confirm('Do a dangerous thing?', default: false)
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#200
    sig { params(question: ::String, default: T::Boolean).returns(T::Boolean) }
    def confirm(question, default: T.unsafe(nil)); end

    # source://cli-ui//lib/cli/ui/prompt.rb#23
    sig { returns(::CLI::UI::Color) }
    def instructions_color; end

    # Set the instructions color.
    #
    # ==== Attributes
    #
    # * +color+ - the color to use for prompt instructions
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#34
    sig { params(color: T.any(::CLI::UI::Color, ::String, ::Symbol)).void }
    def instructions_color=(color); end

    # Wait for any key to be pressed, returning the pressed key.
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#221
    sig { returns(T.nilable(::String)) }
    def read_char; end

    private

    # source://cli-ui//lib/cli/ui/prompt.rb#240
    sig do
      params(
        question: ::String,
        default: T.nilable(::String),
        is_file: T::Boolean,
        allow_empty: T::Boolean
      ).returns(::String)
    end
    def ask_free_form(question, default, is_file, allow_empty); end

    # @raise [ArgumentError]
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#278
    sig do
      params(
        question: ::String,
        options: T.nilable(T::Array[::String]),
        multiple: T::Boolean,
        default: T.nilable(T.any(::String, T::Array[::String])),
        filter_ui: T::Boolean,
        select_ui: T::Boolean
      ).returns(T.any(::String, T::Array[::String]))
    end
    def ask_interactive(question, options = T.unsafe(nil), multiple: T.unsafe(nil), default: T.unsafe(nil), filter_ui: T.unsafe(nil), select_ui: T.unsafe(nil)); end

    # Useful for stubbing in tests
    #
    # source://cli-ui//lib/cli/ui/prompt.rb#339
    sig do
      params(
        options: T::Array[::String],
        multiple: T::Boolean,
        default: T.nilable(T.any(::String, T::Array[::String]))
      ).returns(T.any(::String, T::Array[::String]))
    end
    def interactive_prompt(options, multiple: T.unsafe(nil), default: T.unsafe(nil)); end

    # source://cli-ui//lib/cli/ui/prompt.rb#359
    sig { params(str: ::String).void }
    def puts_question(str); end

    # source://cli-ui//lib/cli/ui/prompt.rb#364
    sig { params(is_file: T::Boolean).returns(::String) }
    def readline(is_file: T.unsafe(nil)); end

    # source://cli-ui//lib/cli/ui/prompt.rb#346
    sig { params(default: ::String).void }
    def write_default_over_empty_input(default); end
  end
end

# source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#10
class CLI::UI::Prompt::InteractiveOptions
  # Initializes a new +InteractiveOptions+
  # Usually called from +self.call+
  #
  # ==== Example Usage:
  #
  #   CLI::UI::Prompt::InteractiveOptions.new(%w(rails go python))
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#60
  sig do
    params(
      options: T::Array[::String],
      multiple: T::Boolean,
      default: T.nilable(T.any(::String, T::Array[::String]))
    ).void
  end
  def initialize(options, multiple: T.unsafe(nil), default: T.unsafe(nil)); end

  # Calls the +InteractiveOptions+ and asks the question
  # Usually used from +self.call+
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#92
  sig { returns(T.any(::Integer, T::Array[::Integer])) }
  def call; end

  private

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#251
  sig { params(char: ::String).void }
  def build_selection(char); end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#112
  sig { void }
  def calculate_option_line_lengths; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#257
  sig { void }
  def chop_selection; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#151
  sig { params(number_of_lines: ::Integer).void }
  def clear_output(number_of_lines = T.unsafe(nil)); end

  # Don't use this in place of +@displaying_metadata+, this updates too
  # quickly to be useful when drawing to the screen.
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#167
  sig { returns(T::Boolean) }
  def display_metadata?; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#438
  sig { returns(::Integer) }
  def distance_from_selection_to_end; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#443
  sig { returns(::Integer) }
  def distance_from_start_to_selection; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#207
  sig { void }
  def down; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#458
  sig { void }
  def ensure_first_item_is_continuation_marker; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#453
  sig { void }
  def ensure_last_item_is_continuation_marker; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#431
  sig { void }
  def ensure_visible_is_active; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#358
  sig { returns(T::Boolean) }
  def filtering?; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#519
  sig { params(format: ::String, choice: ::String).returns(::String) }
  def format_choice(format, choice); end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#363
  sig { returns(T::Boolean) }
  def has_filter?; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#448
  sig { returns(::Integer) }
  def index_of_active_option; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#463
  sig { returns(::Integer) }
  def max_lines; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#172
  sig { returns(::Integer) }
  def num_lines; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#388
  sig { params(recalculate: T::Boolean).returns(T::Array[[::String, T.nilable(::Integer)]]) }
  def presented_options(recalculate: T.unsafe(nil)); end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#289
  sig { void }
  def process_input_until_redraw_required; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#468
  sig { void }
  def render_options; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#142
  sig { params(number_of_lines: ::Integer).void }
  def reset_position(number_of_lines = T.unsafe(nil)); end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#241
  sig { params(char: ::String).void }
  def select_bool(char); end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#281
  sig { void }
  def select_current; end

  # n is 1-indexed selection
  # n == 0 if "Done" was selected in @multiple mode
  #
  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#220
  sig { params(n: ::Integer).void }
  def select_n(n); end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#353
  sig { returns(T::Boolean) }
  def selecting?; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#368
  sig { void }
  def start_filter; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#374
  sig { void }
  def start_line_select; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#381
  sig { void }
  def stop_line_select; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#186
  sig { returns(T::Boolean) }
  def terminal_width_changed?; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#196
  sig { void }
  def up; end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#263
  sig { params(char: ::String).void }
  def update_search(char); end

  # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#296
  sig { void }
  def wait_for_user_input; end

  class << self
    # Prompts the user with options
    # Uses an interactive session to allow the user to pick an answer
    # Can use arrows, y/n, numbers (1/2), and vim bindings to control
    # For more than 9 options, hitting 'e', ':', or 'G' will enter select
    # mode allowing the user to type in longer numbers
    # Pressing 'f' or '/' will allow the user to filter the results
    #
    # https://user-images.githubusercontent.com/3074765/33797984-0ebb5e64-dcdf-11e7-9e7e-7204f279cece.gif
    #
    # ==== Example Usage:
    #
    # Ask an interactive question
    #   CLI::UI::Prompt::InteractiveOptions.call(%w(rails go python))
    #
    # source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#37
    sig do
      params(
        options: T::Array[::String],
        multiple: T::Boolean,
        default: T.nilable(T.any(::String, T::Array[::String]))
      ).returns(T.any(::String, T::Array[::String]))
    end
    def call(options, multiple: T.unsafe(nil), default: T.unsafe(nil)); end
  end
end

# source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#191
CLI::UI::Prompt::InteractiveOptions::BACKSPACE = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#14
CLI::UI::Prompt::InteractiveOptions::CHECKBOX_ICON = T.let(T.unsafe(nil), Hash)

# source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#192
CLI::UI::Prompt::InteractiveOptions::CTRL_C = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#193
CLI::UI::Prompt::InteractiveOptions::CTRL_D = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#13
CLI::UI::Prompt::InteractiveOptions::DONE = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/prompt/interactive_options.rb#190
CLI::UI::Prompt::InteractiveOptions::ESC = T.let(T.unsafe(nil), String)

# A class that handles the various options of an InteractivePrompt and their callbacks
#
# source://cli-ui//lib/cli/ui/prompt/options_handler.rb#8
class CLI::UI::Prompt::OptionsHandler
  # source://cli-ui//lib/cli/ui/prompt/options_handler.rb#12
  sig { void }
  def initialize; end

  # source://cli-ui//lib/cli/ui/prompt/options_handler.rb#27
  sig { params(options: T.any(::String, T::Array[::String])).returns(::String) }
  def call(options); end

  # source://cli-ui//lib/cli/ui/prompt/options_handler.rb#22
  sig { params(option: ::String, handler: T.proc.params(option: ::String).returns(::String)).void }
  def option(option, &handler); end

  # source://cli-ui//lib/cli/ui/prompt/options_handler.rb#17
  sig { returns(T::Array[::String]) }
  def options; end
end

class CLI::UI::ReentrantMutex < ::Thread::Mutex
  def initialize; end

  def count; end
  def lock; end
  def synchronize; end
  def unlock; end

  private

  def decrease_count(thread); end
  def delete_count(thread); end
  def increase_count(thread); end
end

# Convenience accessor to +CLI::UI::Spinner::SpinGroup+
#
# source://cli-ui//lib/cli/ui.rb#29
CLI::UI::SpinGroup = CLI::UI::Spinner::SpinGroup

# source://cli-ui//lib/cli/ui/spinner.rb#8
module CLI::UI::Spinner
  class << self
    # We use this from CLI::UI::Widgets::Status to render an additional
    # spinner next to the "working" element. While this global state looks
    # a bit repulsive at first, it's worth realizing that:
    #
    # * It's managed by the SpinGroup#wait method, not individual tasks; and
    # * It would be complete insanity to run two separate but concurrent SpinGroups.
    #
    # While it would be possible to stitch through some connection between
    # the SpinGroup and the Widgets included in its title, this is simpler
    # in practice and seems unlikely to cause issues in practice.
    #
    # source://cli-ui//lib/cli/ui/spinner.rb#44
    sig { returns(::String) }
    def current_rune; end

    # source://cli-ui//lib/cli/ui/spinner.rb#31
    sig { returns(T.nilable(::Integer)) }
    def index; end

    # @return [Integer, nil]
    #
    # source://cli-ui//lib/cli/ui/spinner.rb#31
    def index=(_arg0); end

    # Adds a single spinner
    # Uses an interactive session to allow the user to pick an answer
    # Can use arrows, y/n, numbers (1/2), and vim bindings to control
    #
    # https://user-images.githubusercontent.com/3074765/33798295-d94fd822-dce3-11e7-819b-43e5502d490e.gif
    #
    # ==== Attributes
    #
    # * +title+ - Title of the spinner to use
    #
    # ==== Options
    #
    # * +:auto_debrief+ - Automatically debrief exceptions or through success_debrief? Default to true
    # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,
    #   or under Sorbet, IO or StringIO. Defaults to $stdout.
    #
    # ==== Block
    #
    # * *spinner+ - Instance of the spinner. Can call +update_title+ to update the user of changes
    #
    # ==== Example Usage:
    #
    #   CLI::UI::Spinner.spin('Title') { sleep 1.0 }
    #
    # source://cli-ui//lib/cli/ui/spinner.rb#84
    sig do
      params(
        title: ::String,
        auto_debrief: T::Boolean,
        to: T.any(::IO, ::StringIO),
        block: T.proc.params(task: ::CLI::UI::Spinner::SpinGroup::Task).void
      ).returns(T::Boolean)
    end
    def spin(title, auto_debrief: T.unsafe(nil), to: T.unsafe(nil), &block); end
  end
end

# source://cli-ui//lib/cli/ui/spinner/async.rb#7
class CLI::UI::Spinner::Async
  # Initializes a new asynchronous spinner with no specific end.
  # Must call +.stop+ to end the spinner
  #
  # ==== Attributes
  #
  # * +title+ - Title of the spinner to use
  #
  # ==== Example Usage:
  #
  #   CLI::UI::Spinner::Async.new('Title')
  #
  # source://cli-ui//lib/cli/ui/spinner/async.rb#33
  sig { params(title: ::String).void }
  def initialize(title); end

  # Stops an asynchronous spinner
  #
  # source://cli-ui//lib/cli/ui/spinner/async.rb#45
  sig { returns(T::Boolean) }
  def stop; end

  class << self
    # Convenience method for +initialize+
    #
    # source://cli-ui//lib/cli/ui/spinner/async.rb#16
    sig { params(title: ::String).returns(::CLI::UI::Spinner::Async) }
    def start(title); end
  end
end

# source://cli-ui//lib/cli/ui/spinner.rb#25
CLI::UI::Spinner::GLYPHS = T.let(T.unsafe(nil), Array)

# seconds
#
# source://cli-ui//lib/cli/ui/spinner.rb#14
CLI::UI::Spinner::PERIOD = T.let(T.unsafe(nil), Float)

# source://cli-ui//lib/cli/ui/spinner.rb#17
CLI::UI::Spinner::RUNES = T.let(T.unsafe(nil), Array)

# source://cli-ui//lib/cli/ui/spinner/spin_group.rb#9
class CLI::UI::Spinner::SpinGroup
  # Initializes a new spin group
  # This lets you add +Task+ objects to the group to multi-thread work
  #
  # ==== Options
  #
  # * +:auto_debrief+ - Automatically debrief exceptions or through success_debrief? Default to true
  # * +:interrupt_debrief+ - Automatically debrief on interrupt. Default to false
  # * +:max_concurrent+ - Maximum number of concurrent tasks. Default is 0 (effectively unlimited)
  # * +:work_queue+ - Custom WorkQueue instance. If not provided, a new one will be created
  # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,
  #   or under Sorbet, IO or StringIO. Defaults to $stdout
  #
  # ==== Example Usage
  #
  #  CLI::UI::SpinGroup.new do |spin_group|
  #    spin_group.add('Title')   { |spinner| sleep 3.0 }
  #    spin_group.add('Title 2') { |spinner| sleep 3.0; spinner.update_title('New Title'); sleep 3.0 }
  #  end
  #
  # Output:
  #
  # https://user-images.githubusercontent.com/3074765/33798558-c452fa26-dce8-11e7-9e90-b4b34df21a46.gif
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#79
  sig do
    params(
      auto_debrief: T::Boolean,
      interrupt_debrief: T::Boolean,
      max_concurrent: ::Integer,
      work_queue: T.nilable(::CLI::UI::WorkQueue),
      to: T.any(::IO, ::StringIO)
    ).void
  end
  def initialize(auto_debrief: T.unsafe(nil), interrupt_debrief: T.unsafe(nil), max_concurrent: T.unsafe(nil), work_queue: T.unsafe(nil), to: T.unsafe(nil)); end

  # Add a new task
  #
  # ==== Attributes
  #
  # * +title+ - Title of the task
  # * +block+ - Block for the task, will be provided with an instance of the spinner
  #
  # ==== Example Usage:
  #   spin_group = CLI::UI::SpinGroup.new
  #   spin_group.add('Title') { |spinner| sleep 1.0 }
  #   spin_group.wait
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#307
  sig do
    params(
      title: ::String,
      final_glyph: T.proc.params(success: T::Boolean).returns(T.any(::CLI::UI::Glyph, ::String)),
      merged_output: T::Boolean,
      duplicate_output_to: ::IO,
      block: T.proc.params(task: ::CLI::UI::Spinner::SpinGroup::Task).void
    ).void
  end
  def add(title, final_glyph: T.unsafe(nil), merged_output: T.unsafe(nil), duplicate_output_to: T.unsafe(nil), &block); end

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#480
  sig { returns(T::Boolean) }
  def all_succeeded?; end

  # Debriefs failed tasks is +auto_debrief+ is true
  #
  # ==== Options
  #
  # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,
  #   or under Sorbet, IO or StringIO. Defaults to $stdout
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#494
  sig { params(to: T.any(::IO, ::StringIO)).returns(T::Boolean) }
  def debrief(to: T.unsafe(nil)); end

  # Provide an alternative debriefing for failed tasks
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#465
  sig do
    params(
      block: T.proc.params(title: ::String, exception: T.nilable(::Exception), out: ::String, err: ::String).void
    ).void
  end
  def failure_debrief(&block); end

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#453
  sig { params(message: ::String).void }
  def puts_above(message); end

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#327
  sig { void }
  def stop; end

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#346
  sig { returns(T::Boolean) }
  def stopped?; end

  # Provide a debriefing for successful tasks
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#475
  sig { params(block: T.proc.params(title: ::String, out: ::String, err: ::String).void).void }
  def success_debrief(&block); end

  # Tells the group you're done adding tasks and to wait for all of them to finish
  #
  # ==== Options
  #
  # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,
  #   or under Sorbet, IO or StringIO. Defaults to $stdout
  #
  # ==== Example Usage:
  #   spin_group = CLI::UI::SpinGroup.new
  #   spin_group.add('Title') { |spinner| sleep 1.0 }
  #   spin_group.wait
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#367
  sig { params(to: T.any(::IO, ::StringIO)).returns(T::Boolean) }
  def wait(to: T.unsafe(nil)); end

  class << self
    # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#16
    sig { returns(::Thread::Mutex) }
    def pause_mutex; end

    # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#28
    sig { type_parameters(:T).params(block: T.proc.returns(T.type_parameter(:T))).returns(T.type_parameter(:T)) }
    def pause_spinners(&block); end

    # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#19
    sig { returns(T::Boolean) }
    def paused?; end
  end
end

# source://cli-ui//lib/cli/ui/spinner/spin_group.rb#10
CLI::UI::Spinner::SpinGroup::DEFAULT_FINAL_GLYPH = T.let(T.unsafe(nil), Proc)

# source://cli-ui//lib/cli/ui/spinner/spin_group.rb#98
class CLI::UI::Spinner::SpinGroup::Task
  # Initializes a new Task
  # This is managed entirely internally by +SpinGroup+
  #
  # ==== Attributes
  #
  # * +title+ - Title of the task
  # * +block+ - Block for the task, will be provided with an instance of the spinner
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#131
  sig do
    params(
      title: ::String,
      final_glyph: T.proc.params(success: T::Boolean).returns(T.any(::CLI::UI::Glyph, ::String)),
      merged_output: T::Boolean,
      duplicate_output_to: ::IO,
      work_queue: ::CLI::UI::WorkQueue,
      block: T.proc.params(task: ::CLI::UI::Spinner::SpinGroup::Task).returns(T.untyped)
    ).void
  end
  def initialize(title, final_glyph:, merged_output:, duplicate_output_to:, work_queue:, &block); end

  # Checks if a task is finished
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#162
  sig { returns(T::Boolean) }
  def check; end

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#108
  sig { returns(T::Boolean) }
  def done; end

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#111
  sig { returns(T.nilable(::Exception)) }
  def exception; end

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#155
  sig { params(block: T.proc.params(task: ::CLI::UI::Spinner::SpinGroup::Task).void).void }
  def on_done(&block); end

  # Re-renders the task if required:
  #
  # We try to be as lazy as possible in re-rendering the full line. The
  # spinner rune will change on each render for the most part, but the
  # body text will rarely have changed. If the body text *has* changed,
  # we set @force_full_render.
  #
  # Further, if the title string includes any CLI::UI::Widgets, we
  # assume that it may change from render to render, since those
  # evaluate more dynamically than the rest of our format codes, which
  # are just text formatters. This is controlled by @always_full_render.
  #
  # ==== Attributes
  #
  # * +index+ - index of the task
  # * +force+ - force rerender of the task
  # * +width+ - current terminal width to format for
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#200
  sig { params(index: ::Integer, force: T::Boolean, width: ::Integer).returns(::String) }
  def render(index, force = T.unsafe(nil), width: T.unsafe(nil)); end

  # @return [String]
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#102
  def stderr; end

  # @return [String]
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#102
  def stdout; end

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#105
  sig { returns(T::Boolean) }
  def success; end

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#102
  sig { returns(::String) }
  def title; end

  # Update the spinner title
  #
  # ==== Attributes
  #
  # * +title+ - title to change the spinner to
  #
  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#219
  sig { params(new_title: ::String).void }
  def update_title(new_title); end

  private

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#230
  sig { params(index: ::Integer, terminal_width: ::Integer).returns(::String) }
  def full_render(index, terminal_width); end

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#256
  sig { params(index: ::Integer).returns(::String) }
  def glyph(index); end

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#276
  sig { returns(::String) }
  def inset; end

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#281
  sig { returns(::Integer) }
  def inset_width; end

  # source://cli-ui//lib/cli/ui/spinner/spin_group.rb#246
  sig { params(index: ::Integer).returns(::String) }
  def partial_render(index); end
end

# source://cli-ui//lib/cli/ui/spinner.rb#15
CLI::UI::Spinner::TASK_FAILED = T.let(T.unsafe(nil), Symbol)

# source://cli-ui//lib/cli/ui/stdout_router.rb#10
module CLI::UI::StdoutRouter
  class << self
    # @raise [NotEnabled]
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#352
    sig { void }
    def assert_enabled!; end

    # source://cli-ui//lib/cli/ui/stdout_router.rb#347
    sig { returns(T.nilable(T::Hash[::Symbol, T.any(::IO, ::String, ::StringIO)])) }
    def current_id; end

    # source://cli-ui//lib/cli/ui/stdout_router.rb#385
    sig { returns(T::Boolean) }
    def disable; end

    # source://cli-ui//lib/cli/ui/stdout_router.rb#327
    sig { returns(T.nilable(T.any(::IO, ::StringIO))) }
    def duplicate_output_to; end

    # @return [IOLike, nil]
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#327
    def duplicate_output_to=(_arg0); end

    # source://cli-ui//lib/cli/ui/stdout_router.rb#371
    sig { returns(T::Boolean) }
    def enable; end

    # source://cli-ui//lib/cli/ui/stdout_router.rb#380
    sig { params(stream: T.any(::IO, ::StringIO)).returns(T::Boolean) }
    def enabled?(stream = T.unsafe(nil)); end

    # TODO: remove this
    #
    # source://cli-ui//lib/cli/ui/stdout_router.rb#366
    sig { void }
    def ensure_activated; end

    # source://cli-ui//lib/cli/ui/stdout_router.rb#357
    sig { type_parameters(:T).params(block: T.proc.returns(T.type_parameter(:T))).returns(T.type_parameter(:T)) }
    def with_enabled(&block); end

    # source://cli-ui//lib/cli/ui/stdout_router.rb#334
    sig do
      type_parameters(:T)
        .params(
          on_streams: T::Array[T.any(::IO, ::StringIO)],
          block: T.proc.params(id: ::String).returns(T.type_parameter(:T))
        ).returns(T.type_parameter(:T))
    end
    def with_id(on_streams:, &block); end

    private

    # source://cli-ui//lib/cli/ui/stdout_router.rb#403
    sig { params(stream: T.any(::IO, ::StringIO), streamname: ::Symbol).void }
    def activate(stream, streamname); end

    # source://cli-ui//lib/cli/ui/stdout_router.rb#396
    sig { params(stream: T.any(::IO, ::StringIO)).void }
    def deactivate(stream); end
  end
end

# source://cli-ui//lib/cli/ui/stdout_router.rb#94
class CLI::UI::StdoutRouter::Capture
  # source://cli-ui//lib/cli/ui/stdout_router.rb#196
  sig do
    params(
      with_frame_inset: T::Boolean,
      merged_output: T::Boolean,
      duplicate_output_to: ::IO,
      block: T.proc.void
    ).void
  end
  def initialize(with_frame_inset: T.unsafe(nil), merged_output: T.unsafe(nil), duplicate_output_to: T.unsafe(nil), &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#212
  sig { returns(T::Boolean) }
  def print_captured_output; end

  # @return [Boolean]
  #
  # source://cli-ui//lib/cli/ui/stdout_router.rb#212
  def print_captured_output=(_arg0); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#215
  sig { returns(T.untyped) }
  def run; end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#258
  sig { returns(::String) }
  def stderr; end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#253
  sig { returns(::String) }
  def stdout; end

  class << self
    # source://cli-ui//lib/cli/ui/stdout_router.rb#106
    sig { returns(T.nilable(::CLI::UI::StdoutRouter::Capture)) }
    def current_capture; end

    # source://cli-ui//lib/cli/ui/stdout_router.rb#111
    sig { returns(::CLI::UI::StdoutRouter::Capture) }
    def current_capture!; end

    # source://cli-ui//lib/cli/ui/stdout_router.rb#116
    sig { type_parameters(:T).params(block: T.proc.returns(T.type_parameter(:T))).returns(T.type_parameter(:T)) }
    def in_alternate_screen(&block); end

    # source://cli-ui//lib/cli/ui/stdout_router.rb#143
    sig { type_parameters(:T).params(block: T.proc.returns(T.type_parameter(:T))).returns(T.type_parameter(:T)) }
    def stdin_synchronize(&block); end

    # source://cli-ui//lib/cli/ui/stdout_router.rb#157
    sig { type_parameters(:T).params(block: T.proc.returns(T.type_parameter(:T))).returns(T.type_parameter(:T)) }
    def with_stdin_masked(&block); end

    private

    # source://cli-ui//lib/cli/ui/stdout_router.rb#183
    sig { returns(T::Boolean) }
    def outermost_uncaptured?; end
  end
end

# source://cli-ui//lib/cli/ui/stdout_router.rb#262
class CLI::UI::StdoutRouter::Capture::BlockingInput
  # source://cli-ui//lib/cli/ui/stdout_router.rb#266
  sig { params(stream: ::IO).void }
  def initialize(stream); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def <<(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def advise(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def autoclose=(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def autoclose?(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def binmode(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def binmode?(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def close(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def close_on_exec=(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def close_on_exec?(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def close_read(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def close_write(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def closed?(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#304
  def each(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#304
  def each_byte(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#304
  def each_char(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#304
  def each_codepoint(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#304
  def each_line(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def eof(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def eof?(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def external_encoding(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def fcntl(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def fdatasync(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def fileno(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def flush(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def fsync(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#304
  def getbyte(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#304
  def getc(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#304
  def getch(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#304
  def gets(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def inspect(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def internal_encoding(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def ioctl(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def isatty(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def lineno(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def lineno=(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def nread(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def path(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def pathconf(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def pid(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def pos(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def pos=(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def pread(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def print(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def printf(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def putc(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def puts(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def pwrite(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#304
  def read(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#304
  def read_nonblock(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#304
  def readbyte(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#304
  def readchar(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#304
  def readline(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#304
  def readlines(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#304
  def readpartial(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def ready?(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def reopen(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def rewind(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def seek(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def set_encoding(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def set_encoding_by_bom(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def stat(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def sync(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def sync=(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#272
  sig { type_parameters(:T).params(block: T.proc.returns(T.type_parameter(:T))).returns(T.type_parameter(:T)) }
  def synchronize(&block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def sysread(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def sysseek(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def syswrite(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def tell(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def timeout(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def timeout=(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def to_i(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def to_io(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def to_path(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def tty?(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def ungetbyte(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def ungetc(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def wait(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def wait_priority(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def wait_readable(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def wait_writable(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def write(*args, **kwargs, &block); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#312
  def write_nonblock(*args, **kwargs, &block); end
end

# source://cli-ui//lib/cli/ui/stdout_router.rb#301
CLI::UI::StdoutRouter::Capture::BlockingInput::NON_READING_METHODS = T.let(T.unsafe(nil), Array)

# source://cli-ui//lib/cli/ui/stdout_router.rb#282
CLI::UI::StdoutRouter::Capture::BlockingInput::READING_METHODS = T.let(T.unsafe(nil), Array)

# source://cli-ui//lib/cli/ui/stdout_router.rb#11
class CLI::UI::StdoutRouter::Writer
  # source://cli-ui//lib/cli/ui/stdout_router.rb#15
  sig { params(stream: T.any(::IO, ::StringIO), name: ::Symbol).void }
  def initialize(stream, name); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#21
  sig { params(args: ::Object).returns(::Integer) }
  def write(*args); end

  private

  # source://cli-ui//lib/cli/ui/stdout_router.rb#77
  sig { params(str: ::String, prefix: ::String).returns(::String) }
  def apply_line_prefix(str, prefix); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#72
  sig { returns(T::Boolean) }
  def auto_frame_inset?; end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#53
  sig { params(stream: T.any(::IO, ::StringIO), args: T::Array[::String]).returns(T::Array[::String]) }
  def prepend_id(stream, args); end

  # source://cli-ui//lib/cli/ui/stdout_router.rb#64
  sig { params(stream: T.any(::IO, ::StringIO)).returns(T::Boolean) }
  def prepend_id_for_stream(stream); end
end

# source://cli-ui//lib/cli/ui/table.rb#5
module CLI::UI::Table
  class << self
    # Captures a table's output as an array of strings without printing to the terminal
    # Can be used to further manipulate or format the table output
    #
    # ==== Attributes
    #
    # * +table+ - (required) 2D array of strings representing the table data
    #
    # ==== Options
    #
    # * +:col_spacing+ - Number of spaces between columns. Defaults to 1
    #
    # ==== Returns
    #
    # * +Array[String]+ - Array of strings, each representing a row of the formatted table
    #
    # ==== Example
    #
    #   CLI::UI::Table.capture_table([
    #     ["{{bold:header_1}}", "{{bold:header_2}}"],
    #     ["really_long_cell",  "short"],
    #     ["row2",              "row2"]
    #   ])
    #
    # source://cli-ui//lib/cli/ui/table.rb#79
    sig { params(table: T::Array[T::Array[::String]], col_spacing: ::Integer).returns(T::Array[::String]) }
    def capture_table(table, col_spacing: T.unsafe(nil)); end

    # Prints a formatted table to the specified output
    # Automatically pads columns to align based on the longest cell in each column,
    # ignoring the width of ANSI color codes.
    #
    # ==== Attributes
    #
    # * +table+ - (required) 2D array of strings representing the table data
    #
    # ==== Options
    #
    # * +:col_spacing+ - Number of spaces between columns. Defaults to 1
    # * +:to+ - Target stream, like $stdout or $stderr. Can be anything with print and puts methods,
    #   or under Sorbet, IO or StringIO. Defaults to $stdout
    #
    # ==== Example
    #
    #   CLI::UI::Table.puts_table([
    #     ["{{bold:header_1}}", "{{bold:header_2}}"],
    #     ["really_long_cell",  "short"],
    #     ["row2",              "row2"]
    #   ])
    #
    # Default Output:
    #   header_1         header_2
    #   really_long_cell short
    #   row2             row2
    #
    # source://cli-ui//lib/cli/ui/table.rb#39
    sig { params(table: T::Array[T::Array[::String]], col_spacing: ::Integer, to: T.any(::IO, ::StringIO)).void }
    def puts_table(table, col_spacing: T.unsafe(nil), to: T.unsafe(nil)); end
  end
end

# source://cli-ui//lib/cli/ui/terminal.rb#9
module CLI::UI::Terminal
  class << self
    # Returns the width of the terminal, if possible
    # Otherwise, will return DEFAULT_HEIGHT
    #
    # source://cli-ui//lib/cli/ui/terminal.rb#30
    sig { returns(::Integer) }
    def height; end

    # source://cli-ui//lib/cli/ui/terminal.rb#51
    sig { void }
    def setup_winsize_trap; end

    # Returns the width of the terminal, if possible
    # Otherwise will return DEFAULT_WIDTH
    #
    # source://cli-ui//lib/cli/ui/terminal.rb#22
    sig { returns(::Integer) }
    def width; end

    # source://cli-ui//lib/cli/ui/terminal.rb#35
    sig { returns([::Integer, ::Integer]) }
    def winsize; end
  end
end

# source://cli-ui//lib/cli/ui/terminal.rb#13
CLI::UI::Terminal::DEFAULT_HEIGHT = T.let(T.unsafe(nil), Integer)

# source://cli-ui//lib/cli/ui/terminal.rb#12
CLI::UI::Terminal::DEFAULT_WIDTH = T.let(T.unsafe(nil), Integer)

# Truncater truncates a string to a provided printable width.
#
# source://cli-ui//lib/cli/ui/truncater.rb#9
module CLI::UI::Truncater
  class << self
    # source://cli-ui//lib/cli/ui/truncater.rb#34
    sig { params(text: ::String, printing_width: ::Integer).returns(::String) }
    def call(text, printing_width); end

    private

    # source://cli-ui//lib/cli/ui/truncater.rb#96
    sig { params(printable_codepoint: ::Integer).returns(::Integer) }
    def width(printable_codepoint); end
  end
end

# EMOJI_RANGE in particular is super inaccurate. This is best-effort.
# If you need this to be more accurate, we'll almost certainly accept a
# PR improving it.
#
# source://cli-ui//lib/cli/ui/truncater.rb#23
CLI::UI::Truncater::EMOJI_RANGE = T.let(T.unsafe(nil), Range)

# source://cli-ui//lib/cli/ui/truncater.rb#15
CLI::UI::Truncater::ESC = T.let(T.unsafe(nil), Integer)

# source://cli-ui//lib/cli/ui/truncater.rb#25
CLI::UI::Truncater::LC_ALPHA_RANGE = T.let(T.unsafe(nil), Range)

# source://cli-ui//lib/cli/ui/truncater.rb#16
CLI::UI::Truncater::LEFT_SQUARE_BRACKET = T.let(T.unsafe(nil), Integer)

# source://cli-ui//lib/cli/ui/truncater.rb#24
CLI::UI::Truncater::NUMERIC_RANGE = T.let(T.unsafe(nil), Range)

# source://cli-ui//lib/cli/ui/truncater.rb#11
CLI::UI::Truncater::PARSE_ANSI = T.let(T.unsafe(nil), Symbol)

# source://cli-ui//lib/cli/ui/truncater.rb#12
CLI::UI::Truncater::PARSE_ESC = T.let(T.unsafe(nil), Symbol)

# source://cli-ui//lib/cli/ui/truncater.rb#10
CLI::UI::Truncater::PARSE_ROOT = T.let(T.unsafe(nil), Symbol)

# source://cli-ui//lib/cli/ui/truncater.rb#13
CLI::UI::Truncater::PARSE_ZWJ = T.let(T.unsafe(nil), Symbol)

# source://cli-ui//lib/cli/ui/truncater.rb#18
CLI::UI::Truncater::SEMICOLON = T.let(T.unsafe(nil), Integer)

# source://cli-ui//lib/cli/ui/truncater.rb#28
CLI::UI::Truncater::TRUNCATED = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/truncater.rb#26
CLI::UI::Truncater::UC_ALPHA_RANGE = T.let(T.unsafe(nil), Range)

# emojipedia.org/emoji-zwj-sequences
#
# source://cli-ui//lib/cli/ui/truncater.rb#17
CLI::UI::Truncater::ZWJ = T.let(T.unsafe(nil), Integer)

# Widgets are formatter objects with more custom implementations than the
# other features, which all center around formatting text with colours,
# etc.
#
# If you want to extend CLI::UI with your own widgets, you may want to do
# something like this:
#
#   require('cli/ui')
#   class MyWidget < CLI::UI::Widgets::Base
#     # ...
#   end
#   CLI::UI::Widgets.register('my-widget') { MyWidget }
#   puts(CLI::UI.fmt("{{@widget/my-widget:args}}"))
#
# source://cli-ui//lib/cli/ui/widgets.rb#21
module CLI::UI::Widgets
  class << self
    # All available widgets by name
    #
    # source://cli-ui//lib/cli/ui/widgets.rb#55
    sig { returns(T::Array[::String]) }
    def available; end

    # Looks up a widget by handle
    #
    # ==== Raises
    # Raises InvalidWidgetHandle if the widget is not available.
    #
    # ==== Returns
    # A callable widget, to be invoked like `.call(argstring)`
    #
    # source://cli-ui//lib/cli/ui/widgets.rb#46
    sig { params(handle: ::String).returns(T.class_of(CLI::UI::Widgets::Base)) }
    def lookup(handle); end

    # source://cli-ui//lib/cli/ui/widgets.rb#33
    sig { params(name: ::String, cb: T.proc.returns(T.class_of(CLI::UI::Widgets::Base))).void }
    def register(name, &cb); end
  end
end

# @abstract It cannot be directly instantiated. Subclasses must implement the `abstract` methods below.
#
# source://cli-ui//lib/cli/ui/widgets/base.rb#9
class CLI::UI::Widgets::Base
  abstract!

  # source://cli-ui//lib/cli/ui/widgets/base.rb#24
  sig { params(argstring: ::String).void }
  def initialize(argstring); end

  # @abstract
  #
  # source://cli-ui//lib/cli/ui/widgets/base.rb#43
  sig { abstract.returns(::String) }
  def render; end

  class << self
    # @abstract
    #
    # source://cli-ui//lib/cli/ui/widgets/base.rb#39
    sig { abstract.returns(::Regexp) }
    def argparse_pattern; end

    # source://cli-ui//lib/cli/ui/widgets/base.rb#18
    sig { params(argstring: ::String).returns(::String) }
    def call(argstring); end
  end
end

# source://cli-ui//lib/cli/ui/widgets.rb#79
class CLI::UI::Widgets::InvalidWidgetArguments < ::ArgumentError
  # source://cli-ui//lib/cli/ui/widgets.rb#83
  sig { params(argstring: ::String, pattern: ::Regexp).void }
  def initialize(argstring, pattern); end

  # source://cli-ui//lib/cli/ui/widgets.rb#90
  sig { returns(::String) }
  def message; end
end

# source://cli-ui//lib/cli/ui/widgets.rb#62
class CLI::UI::Widgets::InvalidWidgetHandle < ::ArgumentError
  # source://cli-ui//lib/cli/ui/widgets.rb#66
  sig { params(handle: ::String).void }
  def initialize(handle); end

  # source://cli-ui//lib/cli/ui/widgets.rb#72
  sig { returns(::String) }
  def message; end
end

# source://cli-ui//lib/cli/ui/widgets.rb#24
CLI::UI::Widgets::MAP = T.let(T.unsafe(nil), Hash)

# source://cli-ui//lib/cli/ui/widgets/status.rb#9
class CLI::UI::Widgets::Status < ::CLI::UI::Widgets::Base
  # source://cli-ui//lib/cli/ui/widgets/status.rb#34
  sig { override.returns(::String) }
  def render; end

  private

  # source://cli-ui//lib/cli/ui/widgets/status.rb#51
  sig { params(num_str: ::String, rune: ::String, color: ::CLI::UI::Color).returns(::String) }
  def colorize_if_nonzero(num_str, rune, color); end

  # source://cli-ui//lib/cli/ui/widgets/status.rb#62
  sig { returns(::String) }
  def failed_part; end

  # source://cli-ui//lib/cli/ui/widgets/status.rb#73
  sig { returns(::String) }
  def pending_part; end

  # source://cli-ui//lib/cli/ui/widgets/status.rb#57
  sig { returns(::String) }
  def succeeded_part; end

  # source://cli-ui//lib/cli/ui/widgets/status.rb#67
  sig { returns(::String) }
  def working_part; end

  # source://cli-ui//lib/cli/ui/widgets/status.rb#46
  sig { params(num_str: ::String).returns(T::Boolean) }
  def zero?(num_str); end

  class << self
    # source://cli-ui//lib/cli/ui/widgets/status.rb#28
    sig { override.returns(::Regexp) }
    def argparse_pattern; end
  end
end

# source://cli-ui//lib/cli/ui/widgets/status.rb#10
CLI::UI::Widgets::Status::ARGPARSE_PATTERN = T.let(T.unsafe(nil), Regexp)

# source://cli-ui//lib/cli/ui/widgets/status.rb#18
CLI::UI::Widgets::Status::ARROW = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/widgets/status.rb#17
CLI::UI::Widgets::Status::CLOSE = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/widgets/status.rb#19
CLI::UI::Widgets::Status::COMMA = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/widgets/status.rb#22
CLI::UI::Widgets::Status::EMPTY_SET = T.let(T.unsafe(nil), String)

# e.g. "1:23:3:404"
#
# source://cli-ui//lib/cli/ui/widgets/status.rb#16
CLI::UI::Widgets::Status::OPEN = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/widgets/status.rb#21
CLI::UI::Widgets::Status::SPINNER_STOPPED = T.let(T.unsafe(nil), String)

# source://cli-ui//lib/cli/ui/work_queue.rb#6
class CLI::UI::WorkQueue
  # source://cli-ui//lib/cli/ui/work_queue.rb#72
  sig { params(max_concurrent: ::Integer).void }
  def initialize(max_concurrent); end

  # source://cli-ui//lib/cli/ui/work_queue.rb#91
  sig { void }
  def close; end

  # source://cli-ui//lib/cli/ui/work_queue.rb#81
  sig { params(block: T.proc.returns(T.untyped)).returns(::CLI::UI::WorkQueue::Future) }
  def enqueue(&block); end

  # source://cli-ui//lib/cli/ui/work_queue.rb#102
  sig { void }
  def interrupt; end

  # source://cli-ui//lib/cli/ui/work_queue.rb#96
  sig { void }
  def wait; end

  private

  # source://cli-ui//lib/cli/ui/work_queue.rb#120
  sig { void }
  def start_worker; end
end

# source://cli-ui//lib/cli/ui/work_queue.rb#9
class CLI::UI::WorkQueue::Future
  # source://cli-ui//lib/cli/ui/work_queue.rb#13
  sig { void }
  def initialize; end

  # source://cli-ui//lib/cli/ui/work_queue.rb#23
  sig { params(result: T.untyped).void }
  def complete(result); end

  # source://cli-ui//lib/cli/ui/work_queue.rb#53
  sig { returns(T::Boolean) }
  def completed?; end

  # source://cli-ui//lib/cli/ui/work_queue.rb#32
  sig { params(error: ::Exception).void }
  def fail(error); end

  # source://cli-ui//lib/cli/ui/work_queue.rb#63
  sig { void }
  def start; end

  # source://cli-ui//lib/cli/ui/work_queue.rb#58
  sig { returns(T::Boolean) }
  def started?; end

  # source://cli-ui//lib/cli/ui/work_queue.rb#43
  sig { returns(T.untyped) }
  def value; end
end

# source://cli-ui//lib/cli/ui/wrap.rb#11
class CLI::UI::Wrap
  # source://cli-ui//lib/cli/ui/wrap.rb#15
  sig { params(input: ::String).void }
  def initialize(input); end

  # source://cli-ui//lib/cli/ui/wrap.rb#20
  sig { params(total_width: ::Integer).returns(::String) }
  def wrap(total_width = T.unsafe(nil)); end
end
